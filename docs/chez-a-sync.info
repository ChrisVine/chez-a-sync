This is chez-a-sync.info, produced by makeinfo version 6.3 from
chez-a-sync.texi.


File: chez-a-sync.info,  Node: Top,  Next: overview

chez-a-sync reference
*********************

This is the chez-a-sync package.  It provides both an asynchronous event
loop for chez scheme, and coroutines to enable an event loop (including
other event loops) to be used with 'await' semantics to deal with
inversion of control - otherwise known as "callback hell".

* Menu:

General overview
* overview::       General overview of the operation of the library

Library files
* coroutines::     (a-sync coroutines) library file - provides coroutines for await semantics on asynchronous events
* event loop::     (a-sync event-loop) library file - provides an event loop for asynchronous events
* compose::        (a-sync compose) library file - provides the compose-a-sync macro interface for the a-sync coroutine
* meeting::        (a-sync meeting) library file - provides for synchronization between a-sync or compose-a-sync blocks
* try::            (a-sync try) library file - provides the try macro interface for dealing with exceptions


File: chez-a-sync.info,  Node: overview,  Next: coroutines,  Prev: Top

*An overview of asynchronous programming with coroutines*

   Asynchronous programming using coroutines might mitigate "callback
hell", but it can still be troublesome to think about.  It can help to
compare it to threads.

   Each 'a-sync' block (see *note (a-sync coroutines): coroutines.) or
'compose-a-sync' block (see *note (a-sync compose): compose.) is a
separate unit of computation, which appears within itself to proceed
sequentially even though in fact it executes asynchronously on an event
loop.  Each such block also appears to execute concurrently with other
'a-sync' or 'compose-a-sync' blocks running on the same event loop.
Each 'a-sync' or 'compose-a-sync' block is therefore in some sense
analogous to a thread of execution.

   If the event loop provided by the *note (a-sync event-loop): event
loop. library file is in use, the mechanism by which these
"pseudo-threads" execute on the event loop is by a call to
event-loop-run!.  event-loop-run!  therefore behaves in a way which is
in some sense analogous to a scheduler, although multi-plexing is
co-operative and/or i/o event based rather than pre-emptive.

   event-loop-run!  also performs the equivalent of a join operation on
these "pseudo-threads" running on the event loop in question, because by
default it returns when there are no further events to be dealt with
(that is, when all "pseudo-threads" have completed).  So given the
following code, the sum of 1 and 1 will only be printed when both the
timeout has expired and the calculation has been made, both of which
will run as if concurrently (the summing will complete before the
timeout expires):

     (let ([loop (make-event-loop)]
           [ret #f])
       (a-sync (lambda (await resume)
     	    (await-timeout! await resume loop
     			    100
     			    (lambda () #f))))
       (a-sync (lambda (await resume)
     	    (set! ret
     		  (await-task! await resume loop
     			       (lambda ()
     				 (+ 1 1))))))
       (event-loop-run! loop)
       (display ret)(newline))

   "Pseudo-threads" (that is 'a-sync' or 'compose-a-sync' blocks)
running on the same event loop can intercommunicate by holding meetings
to exchange a datum (see *note (a-sync meeting): meeting.).  A somewhat
similar result can also be achieved using generators (see the
await-generator!  procedure in the *note (a-sync event-loop): event
loop. library file).

   One interesting feature of these "pseudo-threads" is that where one
'a-sync' or 'compose-a-sync' block is waiting on a read or write watch
(including in the await-get*, await-put*, await-connect!  or
await-accept!  procedures), another a-sync block running on the same
event loop can cause execution of the waiting block to come to an end by
removing the watch using event-loop-remove-read-watch!  or
event-loop-remove-write-watch!, as the case may be (and another native
OS thread can do this by posting an event to the event loop which does
the same).  An example is in the example-server.ss file in the docs
directory.

   Apart from these "pseudo-threads", true parallelism is possible using
native OS threads, with the await-task-in-thread!,
await-task-in-event-loop!, await-generator-in-thread!  and
await-generator-in-event-loop!  procedures.


File: chez-a-sync.info,  Node: coroutines,  Next: event loop,  Prev: overview,  Up: Top

The (a-sync coroutines) library file provides the following procedures:

 -- Scheme Procedure: make-iterator proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs an iterator from them.  When the iterator (which
     optionally takes no or one argument) is invoked, it will begin
     executing the procedure unless and until the argument comprising
     the yield procedure is called, which will cause the iterator to
     suspend computation and instead return the value passed to yield,
     if any (yield is a procedure taking no or one argument).  If
     invoked again, the iterator will resume computation at the point
     where it last left off (returning the value, if any, passed to the
     iterator on resuming).  When the generator procedure has executed
     to the end, the iterator returns 'stop-iteration.  This procedure
     has some resemblance to call/ec, except that (i) instead of
     executing the passed procedure immediately, it returns an iterator
     which will do so, (ii) it is resumable, and (iii) the procedure to
     be executed can receive starting arguments in addition to the
     yield/break argument, to provide an alternative to binding them
     with a lambda closure.  It is similar to ECMAScript generators and
     python generators.

     If 'proc' raises a continuable exception, it will be converted by
     this procedure into a non-continuable exception.

 -- Scheme Procedure: make-coroutine proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs a coroutine.  It is similar to make-iterator, in that it
     takes a generator procedure and returns a lambda object (a
     coroutine) which when called will begin executing the generator
     procedure unless and until the argument comprising the yield
     procedure is called, which will cause computation to be suspended.
     However unlike make-iterator, the resumption continuation generated
     on yielding is returned by the coroutine when yielding rather than
     being stored internally in an iterator, so there is less explicit
     retained mutable state.  The return value of the coroutine
     comprises two values: first the resumption continuation, and second
     the value (if any) passed to 'yield' when called.  If the returned
     resumption continuation is subsequently called again, computation
     will be resumed at the point where it last left off (the yield
     procedure returning the value, if any, passed to the continuation
     on resuming) until it completes or it again calls the yield
     procedure.

     Upon the generator procedure finally completing, the value to which
     it evaluates is returned by the resumption continuation together
     with a continuation value of #f.  This differs from the behaviour
     of make-iterator, which returns 'stop-iteration when the generator
     procedure finishes to completion and ignores its return value.

     If 'proc' raises a continuable exception, it will be converted by
     this procedure into a non-continuable exception.

 -- Scheme Procedure: a-sync waitable . args
     a-sync takes a waitable procedure (namely a procedure which takes
     'await' as its first parameter, which is a yield procedure obtained
     by a call to make-iterator, and 'resume' as its second parameter,
     which is an iterator constructed by make-iterator), followed by
     such other arguments (if any) as the waitable procedure requires to
     be passed on to it.  The 'resume' argument must only be called by
     an asynchronous callback, and the 'await' argument must only be
     called by the waitable procedure in order to block until the
     callback is ready to let it resume.  When it unblocks, the 'await'
     argument returns the value (if any) passed to 'resume' by the
     callback.  This async procedure must be called in the same thread
     as that in which the event loop runs (as must 'await' and
     'resume').

     None of the code in the waitable procedure should block on other
     things in the program, except by calls to await (which do not in
     fact block, even though they appear to do so).

     The way it works is that the call to a-sync will begin executing
     the waitable procedure and will return as soon as the first (or
     only) call to 'await' is made by that procedure, or as soon as the
     waitable procedure returns if it makes no calls to 'await'.  Any
     subsequent resumptions of the waitable procedure will take place in
     the event loop concerned as calls to a relevant continuation
     object, via the calls to 'resume' made by the callbacks.  The
     effect of the waitable procedure subsequently ending, or of further
     calls to 'await' being made within the same waitable procedure, is
     to return control to the event loop by recommencing execution at
     the point where the most recent previous call to 'resume' was made
     by the last callback to execute.

     An exception raised in a waitable procedure before the first call
     to 'await' to be made by it which is not handled locally will
     propagate out of the a-sync procedure where it may be caught
     normally.  However, if so caught but a callback established by the
     same waitable procedure call still runs and invokes 'resume', the
     waitable procedure will begin running again in the callback.  If
     the same exception is raised again in consequence, it will
     propagate out of 'resume' in that callback, and then out of the
     event loop - if the event loop in the event-loop library file is
     used, this means that it will propagate out of the call to
     event-loop-run!.  It is therefore best if such exceptions are
     handled locally within the waitable procedure.  Any exception
     raised in the waitable procedure after the first call to 'await'
     which is not handled locally will propagate into the previously
     called callback at the point where 'resume' was last called.  If
     this is handled in the callback, then control will be returned to
     the event loop and the remainder of the waitable procedure will not
     execute.  If that exception is not handled locally in the callback,
     or if the callback raises an exception of its own, then it will
     propagate out of the event loop - if the event loop in the
     event-loop library file is used, this means that it will propagate
     out of the call to event-loop-run!.  If an exception propagates out
     of event-loop-run!  for that or some other reason, then the event
     loop will be left in a valid state and it will be as if
     event-loop-quit!  had been called on it, but it is then up to the
     user to catch that exception once it is out of event-loop-run!  if
     she does not want the program to terminate.

     With respect to what has been said about exceptions, one further
     feature is that if the waitable procedure raises a continuable
     exception which is not handled locally, it will be converted by
     this procedure into a non-continuable exception.

     After the call to 'resume', the callback should normally just
     return (with a #t or #f value in the case of a file watch or a
     timeout on an event-loop object from the event loop library file).
     If a-sync is used with a file watch or timeout on an event-loop
     object constructed by make-event-loop, the watch callback or
     timeout callback should normally, when the call to 'resume'
     returns, either always return #f (so the callback only fires once)
     or always return #t (so it is responsibility of the waitable
     procedure to terminate the watch or timeout repetitions).  That
     way, there can never be a case where the callback has been removed
     from the event loop by returning false but the waitable procedure
     still thinks it has a call to 'await' to be made.  The *note
     event-loop: event loop. library file has await-task!,
     await-task-in-thread!, await-task-in-event-loop!, await-yield!,
     await-generator!, await-generator-in-thread!,
     await-generator-in-event-loop!, await-timeout!, await-sleep!,
     a-sync-read-watch!, await-getline!, await-geteveryline!,
     await-getsomelines!, await-getblock!, await-geteveryblock!,
     await-getsomeblocks!, a-sync-write-watch!, await-put-bytevector!
     and await-put-string!  convenience procedures which will correctly
     set this up for you automatically, and the *note compose: compose.
     library file provides a compose-a-sync macro for composition.  If
     those convenience procedures are used, exceptions should always be
     handled locally in the waitable procedure (and if the callback
     might throw, in the callback also) if it is undesirable that
     uncaught exceptions propagate out of event-loop-run!.  In the case
     of await-task-in-thread!  and await-generator-in-thread!, those
     procedures also take an optional handler argument which will handle
     any exceptions thrown by the task or generator: otherwise a
     throwing thread would terminate the program if not caught.

     There can be as many calls to 'await' and asynchronous callbacks in
     any one waitable procedure as wanted, to enable composition of
     asynchronous operations.  However, you cannot run two or more
     asynchronous tasks at the same time with the same await-resume pair
     without an intervening call to await except by doing extra work,
     because the first call to 'await' will match the first callback
     which happens to call 'resume', and so on.  In such cases, 'resume'
     would need to return something like a key-value pair so that the
     result can be correctly identified.  Accordingly this practice is
     discouraged.  Instead, when composing asynchronous tasks within any
     one waitable procedure, operate on a 'start-task -> await-on-result
     -> start-task -> await-on-result ...'  basis, and make calls to
     a-sync on separate waitable procedures for tasks which are to run
     independently (as soon as any code calls a-sync's 'await' procedure
     in any a-sync block, a-sync will return and whatever follows it
     will begin executing, including any following a-sync block).  The
     convenience procedures mentioned above make this easy for many use
     cases (see the examples below).  A waitable procedure can itself
     call a-sync to construct another await-resume pair for the purpose
     of starting other asynchronous events.

     So, don't do this:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (format #t "Timeout ~a\n" (await))
          	  (format #t "1 + 1 is ~a\n" (await))))
          (event-loop-run!)

     Instead do this, where the two asynchronous operations are to run
     consecutively:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (format #t "Timeout ~a\n" (await))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (format #t "1 + 1 is ~a\n" (await))))
          (event-loop-run!)

     or this, where the two asynchronous operations are to run
     concurrently (the summing of 1 and 1 will finish before the
     timeout):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (format #t "Timeout ~a\n" (await))))
          (a-sync (lambda (await resume)
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))
          	  (format #t "1 + 1 is ~a\n" (await))))

          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  ;; executing task in event loop thread
          	  (let loop ([count 0])
          	    (if (< count 5)
          		(begin
          		  (event-post! (lambda () (resume (* 2 count))))
          		  (loop (+ count 1)))
          		(event-post! (lambda () (resume 'stop-iteration)))))
          	  (let loop ()
          	    (let ([res (await)])
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))

          	  ;; executing task in a worker thread
          	  (fork-thread
          	   (lambda ()
          	     (let loop ([count 5])
          	       (if (< count 10)
          		   (begin
          		     (event-post! (lambda () (resume (* 2 count))))
          		     (loop (1+ count)))
          		   (event-post! (lambda () (resume 'stop-iteration)))))))
          	  (let loop ()
          	    (let ([res (await)])
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     Or better, for many use cases when composing on the event loop from
     the *note event-loop: event loop. library file, you can use the
     await helper procedures, as follows (in this example the two
     asynchronous operations run consecutively):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (format #t
          		  "Timeout ~a\n"
          		  (await-timeout! await resume
          				  100
          				  (lambda ()
          				    "expired")))
          	  (format #t "1 + 1 is ~a\n"
          		  (await-task! await resume
          			       (lambda ()
          				 (+ 1 1))))))
          (event-loop-run!)

     or this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (format #t
          		  "Timeout ~a\n"
          		  (await-timeout! await resume
          				  100
          				  (lambda ()
          				    "expired")))))
          (a-sync (lambda (await resume)
          	  (format #t "1 + 1 is ~a\n"
          		  (await-task! await resume
          			       (lambda ()
          				 (+ 1 1))))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ([count 0])
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (+ count 1)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ([count 5])
          					  (when (< count 10)
          					    (yield (* 2 count))
          					    (loop (+ count 1)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     Or the compose-a-sync macro in the *note compose: compose. library
     file can be used so that these examples are constructed as follows
     (in this first case the two asynchronous operations run
     consecutively)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ([ret1 (await-timeout! 100
          				       (lambda ()
          					 "expired"))]
          		 [ignore ((no-await (format #t "Timeout ~a\n" ret1)))]
          		 [ret2 (await-task! (lambda ()
          				      (+ 1 1)))])
          	   ((no-await (format #t "1 + 1 is ~a\n" ret2))))
          (event-loop-run!)

     and this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ([ret (await-timeout! 100
          				      (lambda ()
          				        "expired"))])
          	   ((no-await (format #t "Timeout ~a\n" ret))))
          (compose-a-sync ([ret (await-task! (lambda ()
          				     (+ 1 1)))])
          	   ((no-await (format #t "1 + 1 is ~a\n" ret))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ()
          		(await-generator! (lambda (yield)
          				    (let loop ([count 0])
          				      (when (< count 5)
          					(yield (* 2 count))
          					(loop (+ count 1)))))
          				  (lambda (val)
          				    (display val)
          				    (newline)))
          		(await-generator-in-thread! (lambda (yield)
          					      (let loop ([count 5])
          						(when (< count 10)
          						  (yield (* 2 count))
          						  (loop (+ count 1)))))
          					    (lambda (val)
          					      (display val)
          					      (newline)))
          		((no-await (event-loop-block! #f))))
          (event-loop-block! #t) ;; worker thread in operation
          (event-loop-run!)

     For a further overview of the operation of 'a-sync', see the *note
     general overview: overview.


File: chez-a-sync.info,  Node: event loop,  Next: compose,  Prev: overview,  Up: Top

The (a-sync event-loop) library file provides an event loop for
asynchronous operations.  The event loop does not of itself start any
new threads.  Instead it runs in the thread which calls event-loop-run!:
that procedure will block while there are events to be processed.  In
most programs the event loop will run in the main program thread, with
which the program began.  Many programs using event loops are entirely
single threaded.

   However, the event loop provided by this library file does support
multiple threads.  Most of the event loop procedures in this library
file are thread safe and may be called in any thread.  The thread safe
procedures are event-loop-run!  (as mentioned, this will cause the event
loop to run in the thread which calls it), event-loop-block!,
event-loop-quit!, event-post!, event-loop-tasks,
event-loop-add-read-watch!, event-loop-add-write-watch!,
event-loop-remove-read-watch!, event-loop-remove-write-watch!,
timeout-post!  and timeout-remove!.  In particular, event-post!  allows
worker threads to post an event to an event loop, say with the result of
a computation, so that the event callback will execute in the event loop
thread.

   *note (a-sync meeting): meeting. provides synchronization facilities
for event loops provided under this library file.

   The file watches provided by this library file uses chez scheme's FFI
to call a wrapper for the poll() system call.  This has the consequence
that in linux poll() applied to sockets can give rise to spurious
wake-ups, which means that it may be best with sockets to set the socket
as non-blocking to prevent a blocking read or write where it is not
expected.  Non-blocking ports are handled correctly by the
await-getline!, await-geteveryline!, await-getsomelines!,
await-getblock!, await-geteveryblock!, await-getsomeblocks,
await-put-bytevector!  and await-put-string!  procedures.

   Where a file watch on a file descriptor or port has been added with
event-loop-add-read-watch!  or event-loop-add-write-watch!, the event
loop should be treated as owning the status of the port concerned until
it has subsequently been removed with event-loop-remove-read-watch!  or
event-loop-remove-write-watch!.  This is because, if the port concerned
is closed (say by calling close-port, close-input-port or
close-output-port) before its watch has been removed from the event
loop, and the underlying file descriptor value is then reused by the
operating system, there may be a phantom watch on the new descriptor
with an associated attempted read or write on a closed port.  Also note
that if a worker thread other than the event loop thread removes the
watch and immediately follows it with a close of the port concerned, the
file watch callback may be called once in consequence, so in such a case
either the callback should be ready to handle a possibly closed port or
the worker thread should post the closing as an event using event-post!.

   This library files provides the following procedures:

 -- Scheme Procedure: set-default-event-loop! [loop]
     The 'loop' (event loop) argument is optional.  This procedure sets
     the default event loop for the procedures in this library file to
     the one passed in (which must have been constructed by the
     make-event-loop procedure), or if no argument is passed (or #f is
     passed), a new event loop will be constructed for you as the
     default, which can be accessed via the get-default-event-loop
     procedure.  The default loop variable is not a parameter - it is
     intended that the default event loop is the same for every thread
     in the program, and that the default event loop would normally run
     in the thread with which the program started.  This procedure is
     not thread safe - if it might be called by a different thread from
     others which might access the default event loop, then external
     synchronization may be required.  However, that should not normally
     be an issue.  The normal course would be to call this procedure
     once only on program start up, before other threads have started.
     It is usually a mistake to call this procedure twice: if there are
     asynchronous events pending (that is, if event-loop-run!  has not
     returned) you will probably not get the results you expect.

     Note that if a default event-loop is constructed for you because no
     argument is passed (or #f is passed), no throttling arguments are
     applied to it (see the documentation on make-event-loop for more
     about that).  If throttling is wanted, the make-event-loop
     procedure should be called explicitly and the result passed to this
     procedure.

 -- Scheme Procedure: get-default-event-loop
     This returns the default loop set by the set-default-event-loop!
     procedure, or #f if none has been set.

 -- Scheme Procedure: make-event-loop [throttle-threshold
          throttle-delay]
     This constructs a new event loop object.  From version 0.4, this
     procedure optionally takes two throttling arguments for
     backpressure when applying the event-post!  procedure to the event
     loop.  The 'throttle-threshold' argument specifies the number of
     unexecuted tasks queued for execution, by virtue of calls to
     event-post!, at which throttling will first be applied.  Where the
     threshold is exceeded, throttling proceeds by adding a wait to any
     thread which calls the event-post!  procedure, equal to the cube of
     the number of times (if any) by which the number of queued tasks
     exceeds the threshold multiplied by the value of 'threshold-delay'.
     The value of 'threshold-delay' should be given in microseconds.
     Throttling is only applied where the call to event-post!  is made
     in a thread other than the one in which the event loop runs.

     So if the threshold given is 10000 tasks and the delay given is
     1000 microseconds, upon 10000 unexecuted tasks accumulating a delay
     of 1000 microseconds will be applied to callers of event-post!
     which are not in the event loop thread, at 20000 unexecuted tasks a
     delay of 8000 microseconds will be applied, and at 30000 unexecuted
     tasks a delay of 27000 microseconds will be applied, and so on.

     If throttle-threshold and throttle-delay arguments are not provided
     (or #f is passed for them), then no throttling takes place.

 -- Scheme Procedure: event-loop? obj
     This procedure indicates whether 'obj' is an event-loop object
     constructed by make-event-loop.

 -- Scheme Procedure: event-loop-run! [loop]
     The 'loop' (event loop) argument is optional.  This procedure
     starts the event loop passed in as an argument, or if none is
     passed (or #f is passed) it starts the default event loop.  The
     event loop will run in the thread which calls this procedure.  If
     this procedure has returned, including after a call to
     event-loop-quit!, this procedure may be called again to restart the
     event loop.

     If a callback throws, or something else throws in the
     implementation, then this procedure will clean up the event loop as
     if event-loop-quit!  had been called, and the exception will be
     rethrown out of this procedure.  This means that if there are
     continuable exceptions, they will be converted into non-continuable
     ones (but continuable exceptions are usually incompatible with
     asynchronous event handlers and may break resource management using
     rethrows or dynamic winds).

 -- Scheme Procedure: event-loop-add-read-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a read watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'in or 'excpt.  The same port or file
     descriptor can also be passed to event-loop-add-write-watch, and if
     so and the descriptor is also available for writing, the write
     callback will also be called with its argument set to 'out.  If
     there is already a read watch for the file passed, the old one will
     be replaced by the new one.  If 'proc' returns #f, the read watch
     will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.  If 'file' is a buffered port,
     buffering will be taken into account in indicating whether a read
     can be made without blocking (but on a buffered port, for
     efficiency purposes each read operation in response to this watch
     should usually exhaust the buffer by looping on char-ready?  or
     input-port-ready?, or by using chez scheme's various
     multi-byte/character reading procedures on non-blocking ports).

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-add-write-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a write watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'out.  The same port or file descriptor can
     also be passed to event-loop-add-read-watch, and if so and the
     descriptor is also available for reading or in exceptional
     condition, the read callback will also be called with its argument
     set to 'in or 'excpt (if both a read and a write watch have been
     set for the same file argument, and there is an exceptional
     condition, it is the read watch procedure which will be called with
     'excpt rather than the write watch procedure, so if that procedure
     returns #f only the read watch will be removed).  If there is
     already a write watch for the file passed, the old one will be
     replaced by the new one.  If 'proc' returns #f, the write watch
     will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.

     If 'file' is a buffered port, buffering will be not be taken into
     account in indicating whether a write can be made without blocking:
     that will only occur if the underlying file descriptor is ready.
     This is because the writer to the port must in any event cater for
     the fact that when the buffer is full but the underlying file
     descriptor is ready for a character, the next write will cause a
     buffer flush, and if the size of the buffer is greater than the
     number of characters that the file can receive without blocking,
     blocking might still occur.  Therefore, this procedure will
     generally work best with unbuffered ports (say by using the
     open-file-output-port procedure with a buffer-mode of none or by
     applying the set-textual-port-output-size!  procedure to the port
     with a value of 0), or with ports which have been set non-blocking
     so that a partial write is possible without blocking the writer.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-remove-read-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a read watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

 -- Scheme Procedure: event-loop-remove-write-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a write watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

 -- Scheme Procedure: event-post! action [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     post a callback for execution in the event loop passed in as an
     argument, or if none is passed (or #f is passed), in the default
     event loop.  The 'action' callback is a thunk.  This is thread safe
     - any thread may post an event (that is its main purpose), and the
     action callback will execute in the event loop thread.  Actions
     execute in the order in which they were posted.  If an event is
     posted from a worker thread, it will normally be necessary to call
     event-loop-block!  beforehand.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

     Where this procedure is called by other than the event loop thread,
     throttling may take place if the number of posted callbacks waiting
     to execute exceeds the threshold set for the event loop - see the
     documentation on make-event-loop for further details.

 -- Scheme Procedure: timeout-post! msecs action [loop]
     The 'loop' (event loop) argument is optional.  This procedure adds
     a timeout to the event loop passed in as an argument, or if none is
     passed (or #f is passed), to the default event loop.  The timeout
     will repeat unless and until the passed-in callback returns #f or
     timeout-remove!  is called.  The passed-in callback must be a
     thunk.  This procedure returns a tag symbol to which
     timeout-remove!  can be applied.  It may be called by any thread,
     and the timeout callback will execute in the event loop thread.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

 -- Scheme Procedure: timeout-remove! tag [loop]
     The 'loop' (event loop) argument is optional.  This procedure stops
     the timeout with the given tag from executing in the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     in the default event loop.  It may be called by any thread.

 -- Scheme Procedure: event-loop-tasks [loop]
     This procedure returns the number of callbacks posted to an event
     loop with the event-post!  procedure which at the time still remain
     queued for execution.  Amongst other things, it can be used by a
     calling thread which is not the event loop thread to determine
     whether throttling is likely to be applied to it when calling
     event-post!  - see the documentation on make-event-loop for further
     details.

     The 'loop' (event loop) argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.  This
     procedure is thread safe - any thread may call it.

     This procedure is first available in version 0.4 of this library.

 -- Scheme Procedure: event-loop-block! val [loop]
     By default, upon there being no more watches, timeouts and posted
     events for an event loop, event-loop-run!  will return, which is
     normally what you want with a single threaded program.  However,
     this is undesirable where a worker thread is intended to post an
     event to the main loop after it has reached a result, say via
     await-task-in-thread!, because the main loop may have ended before
     it posts.  Passing #t to the val argument of this procedure will
     prevent that from happening, so that the event loop can only be
     ended by calling event-loop-quit!, or by calling event-loop-block!
     again with a #f argument (to switch the event loop back to
     non-blocking mode, pass #f).  This is thread safe - any thread may
     call this procedure.  The 'loop' (event loop) argument is optional:
     this procedure operates on the event loop passed in as an argument,
     or if none is passed (or #f is passed), on the default event loop.

 -- Scheme Procedure: event-loop-quit! [loop]
     This procedure causes an event loop to unblock.  Any events
     remaining in the event loop will be discarded.  New events may
     subsequently be added after event-loop-run!  has unblocked and
     event-loop-run!  then called for them.  This is thread safe - any
     thread may call this procedure.  The 'loop' (event loop) argument
     is optional: this procedure operates on the event loop passed in as
     an argument, or if none is passed (or #f is passed), on the default
     event loop.

 -- Scheme Procedure: await-task-in-thread! await resume [loop] thunk
          [handler]
     The loop and handler arguments are optional.  The procedure will
     run 'thunk' in its own thread, and then post an event to the event
     loop specified by the 'loop' argument when 'thunk' has finished, or
     to the default event loop if no 'loop' argument is provided or if
     #f is provided as the 'loop' argument (pattern matching is used to
     detect the type of the third argument).  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called within a waitable procedure invoked by a-sync (which
     supplies the 'await' and 'resume' arguments).  It will normally be
     necessary to call event-loop-block!  before invoking this
     procedure.  If the optional 'handler' argument is provided, then
     that handler will be run in the event loop thread if 'thunk' throws
     and the return value of the handler would become the return value
     of this procedure; otherwise the program will terminate if an
     unhandled exception propagates out of 'thunk'.  'handler' should
     take a single argument, which will be the thrown condition object.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs, where the result
     of calling 'thunk' will be received.  As mentioned above, the thunk
     itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (format #t "1 + 1 is ~A\n"
          		  (await-task-in-thread! await resume
          					 (lambda ()
          					   (+ 1 1))))
          	  (event-loop-quit!)))
          (event-loop-block! #t) ;; because the task runs in another thread
          (event-loop-run!)

 -- Scheme Procedure: await-task-in-event-loop! await resume [waiter]
          worker thunk
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called, and is the one in which 'thunk' will be
     executed by posting an event to that loop.  The result of executing
     'thunk' will then be posted to the event loop specified by the
     'waiter' argument, or to the default event loop if no 'waiter'
     argument is provided or if #f is provided as the 'waiter' argument,
     and will comprise this procedure's return value.  This procedure is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  It will
     normally be necessary to call event-loop-block!  on 'waiter' (or on
     the default event loop) before invoking this procedure.

     This procedure calls 'await' and must (like the a-sync procedure)
     be called in the same thread as that in which the 'waiter' or
     default event loop runs (as the case may be).

     This procedure acts as a form of channel through which two
     different event loops may communicate.  It also offers a means by
     which a master event loop (the waiter or default event loop) may
     allocate work to worker event loops for execution.  It would be
     nice to have a pool of worker event loops for the purpose, but that
     is a work for the future.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     the event-loop-run!  procedure called for the 'worker' event loop.

     This procedure is first available in version 0.4 of this library.

     Here is an example of the use of await-task-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the task runs in another thread
          (event-loop-block! #t worker)

          (fork-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (let ([res
          		 (await-task-in-event-loop! await resume worker
          					    (lambda ()
          					      (+ 5 10)))])
          	    (format #t "~a\n" res)
          	    (event-loop-block! #f worker)
          	    (event-loop-block! #f))))
          (event-loop-run!)

 -- Scheme Procedure: await-task! await resume [loop] thunk
     The 'loop' argument is optional.  This is a convenience procedure
     for use with an event loop, which will run 'thunk' in the event
     loop specified by the 'loop' argument, or in the default event loop
     if no 'loop' argument is provided or #f is provided as the 'loop'
     argument.  This procedure calls 'await' and will return the thunk's
     return value.  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  It is the single-threaded corollary of
     await-task-in-thread!.  This means that (unlike with
     await-task-in-thread!)  while 'thunk' is running other events in
     the event loop will not make progress, so blocking calls should not
     be made in 'thunk'.

     This procedure can be used for the purpose of implementing
     co-operative multi-tasking.  However, when 'thunk' is executed,
     this procedure is waiting on 'await', so 'await' and 'resume'
     cannot be used again in 'thunk' (although 'thunk' can call a-sync
     to start another series of asynchronous operations with a new
     await-resume pair).  For that reason, await-yield!  is usually more
     convenient for composing asynchronous tasks.  In retrospect, this
     procedure offers little over await-yield!, apart from symmetry with
     await-task-in-thread!.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (format #t "1 + 1 is ~A\n"
          		  (await-task! await resume
          			       (lambda ()
          				 (+ 1 1))))))
          (event-loop-run!)

 -- Scheme Procedure: await-yield! await resume [loop]
     This is a convenience procedure which will surrender execution to
     the relevant event loop, so that code in other a-sync or
     compose-a-sync blocks can run.  The remainder of the code after the
     call to await-yield!  in the current a-sync or compose-a-sync block
     will execute on the next iteration through the loop.  It is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  It's effect
     is similar to calling await-task!  with a task that does nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the relevant event loop runs: for this
     purpose "the relevant event loop" is the event loop given by the
     'loop' argument, or if no 'loop' argument is provided or #f is
     provided as the 'loop' argument, then the default event loop.

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     This procedure should not raise any exceptions unless memory is
     exhausted.

     This procedure is first available in version 0.9 of this library.

     Here is an example of the use of await-yield!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "In first iteration through event loop\n")
          	  (await-yield! await resume)
          	  (display "In next iteration through event loop\n")))
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-thread! await resume [loop]
          generator proc [handler]
     The 'loop' and 'handler' arguments are optional.  The 'generator'
     argument is a procedure taking one argument, namely a yield
     argument (see the documentation on the make-iterator procedure for
     further details).  This await-generator-in-thread!  procedure will
     run 'generator' in its own worker thread, and whenever 'generator'
     yields a value will cause 'proc' to execute in the event loop
     specified by the 'loop' argument (or in the default event loop if
     no 'loop' argument is provided or if #f is provided as the 'loop'
     argument - pattern matching is used to detect the type of the third
     argument).

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the event loop thread
     if 'generator' raises an exception; otherwise the program will
     terminate if an unhandled exception propagates out of 'generator'.
     'handler' should take a single argument, which will be the raised
     condition object.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator raising
     an exception.  This procedure will return #f if the generator
     completes normally, or 'chez-a-sync-thread-error if the generator
     raises an exception and 'handler' is run (the
     'chez-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  before invoking this procedure.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.  As mentioned
     above, the generator itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions raised by the handler procedure will propagate
     out of event-loop-run!.  Exceptions raised by 'proc', if not caught
     locally, will also propagate out of event-loop-run!.

     This procedure is first available in version 0.6 of this library.

     Here is an example of the use of await-generator-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ([count 0])
          					  (when (< count 5)
          					    (yield (* 2 count))
          					    (loop (+ count 1)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-block! #t) ;; because the generator runs in another thread
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-event-loop! await resume
          [waiter] worker generator proc
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called.  The 'generator' argument is a procedure
     taking one argument, namely a yield argument (see the documentation
     on the make-iterator procedure for further details).  This
     await-generator-in-event-loop!  procedure will cause 'generator' to
     run in the 'worker' event loop, and whenever 'generator' yields a
     value this will cause 'proc' to execute in the event loop specified
     by the 'waiter' argument, or in the default event loop if no
     'waiter' argument is provided or if #f is provided as the 'waiter'
     argument.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  on 'waiter' (or on the default event loop)
     before invoking this procedure.

     This procedure calls 'await' and will return when the generator has
     finished.  It must (like the a-sync procedure) be called in the
     same thread as that in which the 'waiter' or default event loop
     runs (as the case may be).

     This procedure acts, with await-task-in-event-loop!, as a form of
     channel through which two different event loops may communicate.
     It also offers a means by which a master event loop (the waiter or
     default event loop) may allocate work to worker event loops for
     execution.  It would be nice to have a pool of worker event loops
     for the purpose, but that is a work for the future.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of the event-loop-run!  procedure called for the 'worker' event
     loop.  Exceptions arising during the execution of 'proc', if not
     caught locally, will propagate out of the event-loop-run!
     procedure called for the 'waiter' or default event loop (as the
     case may be).

     This procedure is first available in version 0.6 of this library.

     Here is an example of the use of await-generator-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the generator runs in another thread
          (event-loop-block! #t worker)

          (fork-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (await-generator-in-event-loop! await resume worker
          					  (lambda (yield)
          					    (let loop ([count 0])
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (+ count 1)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (event-loop-block! #f worker)
          	  (event-loop-block! #f)))
          (event-loop-run!)

 -- Scheme Procedure: await-generator! await resume [loop] generator
          proc
     The 'loop' argument is optional.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-generator!  procedure will run 'generator', and whenever
     'generator' yields a value will cause 'proc' to execute in the
     event loop specified by the 'loop' argument, or in the default
     event loop if no 'loop' argument is provided or #f is provided as
     the 'loop' argument.  'proc' should be a procedure taking a single
     argument, namely the value yielded by the generator.  Each time
     'proc' runs it will do so as a separate event in the event loop and
     so be multi-plexed with other events.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It is the single-threaded corollary of
     await-generator-in-thread!.  This means that (unlike with
     await-generator-in-thread!)  while 'generator' is running other
     events in the event loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.  This procedure can be useful for the purpose of
     implementing co-operative multi-tasking, say by composing tasks
     with compose-a-sync (see compose.scm).

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of await-generator!.  Exceptions raised by 'proc', if not
     caught locally, will propagate out of event-loop-run!.

     This procedure is first available in version 0.6 of this library.

     Here is an example of the use of await-generator!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ([count 0])
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (+ count 1)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))))
          (event-loop-run!)

 -- Scheme Procedure: await-timeout! await resume [loop] msecs thunk
     This is a convenience procedure for use with an event loop, which
     will run 'thunk' in the event loop thread when the timeout expires.
     This procedure calls 'await' and will return the thunk's return
     value.  It is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  The timeout is single shot only - as soon as 'thunk'
     has run once and completed, the timeout will be removed from the
     event loop.  The 'loop' argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.

     In practice, calling await-sleep!  may often be more convenient for
     composing asynchronous code than using this procedure.  That is
     because, when 'thunk' is executed, this procedure is waiting on
     'await', so 'await' and 'resume' cannot be used again in 'thunk'
     (although 'thunk' can call a-sync to start another series of
     asynchronous operations with a new await-resume pair).  In
     retrospect, this procedure offers little over await-sleep!.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     raised by 'thunk', if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of event-timeout!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (format #t
          		  "Timeout ~A\n"
          		  (await-timeout! await resume
          				  100
          				  (lambda ()
          				    "expired")))))
          (event-loop-run!)

 -- Scheme Procedure: await-sleep! await resume [loop] msecs
     This is a convenience procedure which will suspend execution of
     code in the current a-sync or compose-a-sync block for the duration
     of 'msecs' milliseconds.  The event loop will not be blocked by the
     sleep - instead any other events in the event loop (including any
     other a-sync or compose-a-sync blocks) will be serviced.  It is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.

     Calling this procedure is equivalent to calling await-timeout!
     with a 'proc' argument comprising a lambda expression that does
     nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     This procedure is first available in version 0.9 of this library.

     Here is an example of the use of await-sleep!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Entering sleep\n")
          	  (await-sleep! await resume 500)
          	  (display "Timeout expired\n")))
          (event-loop-run!)

 -- Scheme Procedure: a-sync-read-watch! resume file proc [loop]
     This is a convenience procedure for use with an event loop, which
     will run 'proc' in the event loop thread whenever 'file' is ready
     for reading, and apply 'resume' (obtained from a call to a-sync) to
     the return value of 'proc'.  'file' can be a port or a file
     descriptor (and if it is a file descriptor, the revealed count is
     not incremented).  'proc' should take a single argument which will
     be set by the event loop to 'in or 'excpt (see the documentation on
     event-loop-add-read-watch!  for further details).  It is intended
     to be called within a waitable procedure invoked by a-sync (which
     supplies the 'resume' argument).  The watch is multi-shot - it is
     for the user to bring it to an end at the right time by calling
     event-loop-remove-read-watch!  in the waitable procedure.  If
     'file' is a buffered port, buffering will be taken into account in
     indicating whether a read can be made without blocking (but on a
     buffered port, for efficiency purposes each read operation in
     response to this watch should usually exhaust the buffer by looping
     on char-ready?  or input-port-ready?, or by using chez scheme's
     various multi-byte/character reading procedures on non-blocking
     ports).

     This procedure is mainly intended as something from which
     higher-level asynchronous file operations can be constructed, such
     as the await-readline!  procedure.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the event loop runs.

     This procedure should not raise an exception unless memory is
     exhausted.  If 'proc' raises an exception, say because of port
     errors, and the exception is not caught locally, it will propagate
     out of event-loop-run!.

     As an example of how to use a-sync-read-watch!, here is the
     implementation of await-getline!:
          (define await-getline!
            (case-lambda
              [(await resume port) (await-getline! await resume #f port)]
              [(await resume loop port)
               (let ()
                 (define chunk-size 128)
                 (define text (make-string chunk-size))
                 (define text-len 0)
                 (define buf (make-string 1))
                 (define (append-char! ch)
          	 (when (= text-len (string-length text))
          	   (let ([tmp text])
          	     (set! text (make-string (+ text-len chunk-size)))
          	     (string-copy! tmp 0 text 0 text-len)))
          	 (string-set! text text-len ch)
          	 (set! text-len (+ 1 text-len)))
                 (a-sync-read-watch! resume
          			   port
          			   (lambda (status)
          			     (if (eq? status 'excpt)
          				 #f
          				 (let next ([res (get-string-some! port buf 0 1)])
          				   (cond
          				    [(eqv? res 0)
          				     'more]
          				    [(eof-object? res)
          				     (if (= text-len 0)
          					 res
          					 (substring text 0 text-len))]
          				    [else
          				     (let ([ch (string-ref buf 0)])
          				       (if (char=? ch #\newline)
          					   (substring text 0 text-len)
          					   (begin
          					     (append-char! ch)
          					     (if (char-ready? port)
          						 (next (get-string-some! port buf 0 1))
          						 'more))))]))))
          			   loop))
               (let next ((res (await)))
                 (if (eq? res 'more)
          	   (next (await))
          	   (begin
          	     (event-loop-remove-read-watch! port loop)
          	     res)))]))

 -- Scheme Procedure: await-getline! await resume [loop] port
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for a line of input.  It calls
     'await' while waiting for input and will return the line of text
     received (without the terminating '\n' character).  'port' should
     be a textual portg.  The event loop will not be blocked by this
     procedure even if only individual characters are available at any
     one time (although if 'port' references a socket, it should be
     non-blocking for this to be guaranteed).  It is intended to be
     called within a waitable procedure invoked by a-sync (which
     supplies the 'await' and 'resume' arguments), and this procedure is
     implemented using a-sync-read-watch!.  If an exceptional condition
     ('excpt) is encountered, #f will be returned.  If an end-of-file
     object is encountered which terminates a line of text, a string
     containing the line of text will be returned (and if an end-of-file
     object is encountered without any text, the end-of-file object is
     returned rather than an empty string).  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.

     Here is an example of the use of await-getline!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter a line of text at the keyboard\n")
          	  (format #t
          		  "The line was: ~A\n"
          		  (await-getline! await resume
          				  (open-input-file "/dev/tty")))))
          (event-loop-run!)

 -- Scheme Procedure: await-geteveryline! await resume [loop] port proc
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for lines of input.  It calls
     'await' while waiting for input and will apply 'proc' to every
     complete line of text received (without the terminating '\n'
     character).  'proc' should be a procedure taking a string as its
     only argument.  'port' should be a textual port.

     The event loop will not be blocked by this procedure even if only
     individual characters are available at any one time (although if
     'port' references a socket, it should be non-blocking for this to
     be guaranteed).  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments), and this procedure is implemented using
     a-sync-read-watch!.  Unlike the await-getline!  procedure, the
     watch will continue after a line of text has been received in order
     to receive further lines.  The watch will not end until end-of-file
     or an exceptional condition ('excpt) is reached.  In the event of
     that happening, this procedure will end and return an end-of-file
     object or #f respectively.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.  Exceptions raised by 'proc', if not caught locally, will also
     propagate out of event-loop-run!.

     If a continuable exception propagates out of this procedure, it
     will be converted into a non-continuable one (continuable
     exceptions are incompatible with asynchronous event handling using
     this procedure and may break resource management which uses
     rethrows or dynamic winds).

     Here is an example of the use of await-geteveryline!  (because the
     keyboard has no end-of-file, use Ctrl-C to exit this code snippet):
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, ^C to finish\n")
          	  (let ([port (open-input-file "/dev/tty")])
          	    (await-geteveryline! await resume
          				 port
          				 (lambda (line)
          				   (format #t
          					   "The line was: ~A\n"
          					   line))))))
          (event-loop-run!)

 -- Scheme Procedure: await-getsomelines! await resume [loop] port proc
     This is a convenience procedure for use with an event loop, which
     does the same as await-geteveryline!, except that it provides a
     second argument to 'proc', namely an escape continuation which can
     be invoked by 'proc' to cause the procedure to return before
     end-of-file is reached.  Behavior is identical to
     await-geteveryline!  if the continuation is not invoked.

     This procedure will start a read watch on 'port' for lines of
     input.  It calls 'await' while waiting for input and will apply
     'proc' to any complete line of text received (without the
     terminating '\n' character).  'proc' should be a procedure taking
     two arguments, a string as the first argument containing the line
     of text read, and an escape continuation as its second.  'port'
     should be a textual port.

     The event loop will not be blocked by this procedure even if only
     individual characters are available at any one time (although if
     'port' references a socket, it should be non-blocking for this to
     be guaranteed).  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  This procedure is implemented using
     a-sync-read-watch!.  The watch will not end until end-of-file or an
     exceptional condition ('excpt) is reached, which would cause this
     procedure to end and return an end-of-file object or #f
     respectively, or until the escape continuation is invoked, in which
     case the value passed to the escape continuation will be returned.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.  Exceptions raised by 'proc', if not caught locally, will also
     propagate out of event-loop-run!.

     If a continuable exception propagates out of this procedure, it
     will be converted into a non-continuable one (continuable
     exceptions are incompatible with asynchronous event handling using
     this procedure and may break resource management which uses
     rethrows or dynamic winds).

     Here is an example of the use of await-getsomelines!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, enter an empty line to finish\n")
          	  (let ([port (open-input-file "/dev/tty")])
          	    (await-getsomelines! await resume
          				 port
          				 (lambda (line k)
                                             (when (string=? line "")
          					 (k #f))
          				   (format #t
          					   "The line was: ~A\n"
          					   line))))))
          (event-loop-run!)

 -- Scheme Procedure: await-getblock! await resume [loop] port size
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for a block of data, such as a
     binary record, of size 'size'.  It calls 'await' while waiting for
     input and will return a pair, normally comprising as its car a
     bytevector of length 'size' containing the data, and as its cdr the
     number of bytes received (which will be the same as 'size' unless
     an end-of-file object was encountered part way through receiving
     the data).  'port' should be a binary port.

     The event loop will not be blocked by this procedure even if only
     individual bytes are available at any one time (although if 'port'
     references a socket, it should be non-blocking for this to be
     guaranteed).  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  This procedure is implemented using
     a-sync-read-watch!.

     If an exceptional condition ('excpt) is encountered, a pair
     comprising (#f .  #f) will be returned.  As mentioned above, if an
     end-of-file object is encountered after receipt of some but not
     'size' bytes, then a bytevector of length 'size' will be returned
     as car and the actual (lesser) number of bytes inserted in it as
     cdr.  If an end-of-file object is encountered without any bytes of
     data, a pair with eof-object as car and #f as cdr will be returned.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.

     This procedure is first available in version 0.8 of this library.

 -- Scheme Procedure: await-geteveryblock! await resume [loop] port size
          proc
     This is a convenience procedure for use with an event loop, which
     will start a read watch on 'port' for blocks of data, such as
     binary records, of size 'size'.  It calls 'await' while waiting for
     input and will apply 'proc' to any block of data received.  'proc'
     should be a procedure taking two arguments, first a bytevector of
     length 'size' containing the block of data read and second the size
     of the block of data placed in the bytevector.  The value passed as
     the size of the block of data placed in the bytevector will always
     be the same as 'size' unless end-of-file has been encountered after
     receiving only a partial block of data.  'port' should be a binary
     port.

     The event loop will not be blocked by this procedure even if only
     individual bytes are available at any one time (although if 'port'
     references a socket, it should be non-blocking for this to be
     guaranteed).  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  This procedure is implemented using
     a-sync-read-watch!.  Unlike the await-getblock!  procedure, the
     watch will continue after a complete block of data has been
     received in order to receive further blocks.  The watch will not
     end until end-of-file or an exceptional condition ('excpt) is
     reached.  In the event of that happening, this procedure will end
     and return an end-of-file object or #f respectively.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.  Exceptions raised by 'proc', if not caught locally, will also
     propagate out of event-loop-run!.

     If a continuable exception propagates out of this procedure, it
     will be converted into a non-continuable one (continuable
     exceptions are incompatible with asynchronous event handling using
     this procedure and may break resource management which uses
     rethrows or dynamic winds).

     This procedure is first available in version 0.8 of this library.

 -- Scheme Procedure: await-getsomeblocks! await resume [loop] port size
          proc
     This is a convenience procedure for use with an event loop, which
     does the same as await-geteveryblock!, except that it provides a
     third argument to 'proc', namely an escape continuation which can
     be invoked by 'proc' to cause the procedure to return before
     end-of-file is reached.  Behavior is identical to
     await-geteveryblock!  if the continuation is not invoked.

     This procedure will start a read watch on 'port' for blocks of
     data, such as binary records, of size 'size'.  It calls 'await'
     while waiting for input and will apply 'proc' to any block of data
     received.  'proc' should be a procedure taking three arguments,
     first a bytevector of length 'size' containing the block of data
     read, second the size of the block of data placed in the bytevector
     and third an escape continuation.  The value passed as the size of
     the block of data placed in the bytevector will always be the same
     as 'size' unless end-of-file has been encountered after receiving
     only a partial block of data.  'port' should be a binary port.

     The event loop will not be blocked by this procedure even if only
     individual bytes are available at any one time (although if 'port'
     references a socket, it should be non-blocking for this to be
     guaranteed).  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  This procedure is implemented using
     a-sync-read-watch!.  The watch will not end until end-of-file or an
     exceptional condition ('excpt) is reached, which would cause this
     procedure to end and return an end-of-file object or #f
     respectively, or until the escape continuation is invoked, in which
     case the value passed to the escape continuation will be returned.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     If this procedure is used with a port constructed by
     'open-fd-input/output-port' for a non-seekable device such as a
     socket which has input buffering enabled, the 'clear-input-port'
     procedure should be applied to the port before 'close-port',
     'close-output-port' or 'close-input-port' is applied to it, to
     avoid an illegal seek exception.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  With versions
     of this library before 0.11, any exceptions because of read errors
     would propagate out of event-loop-run!  and could not be caught
     locally.  Having read errors interfering with anything using the
     event loop in this way was not a good approach, so from version
     0.11 of this library all read exceptions will propagate in the
     first instance out of this procedure so that they may be caught
     locally, say by putting a 'try' block around the call to this
     procedure, and only out of event-loop-run!  if not caught in that
     way.  Exceptions raised by 'proc', if not caught locally, will also
     propagate out of event-loop-run!.

     If a continuable exception propagates out of this procedure, it
     will be converted into a non-continuable one (continuable
     exceptions are incompatible with asynchronous event handling using
     this procedure and may break resource management which uses
     rethrows or dynamic winds).

     This procedure is first available in version 0.8 of this library.

 -- Scheme Procedure: a-sync-write-watch! resume file proc [loop]
     This is a convenience procedure for use with an event loop, which
     will run 'proc' in the event loop thread whenever 'file' is ready
     for writing, and apply 'resume' (obtained from a call to a-sync) to
     the return value of 'proc'.  'file' can be a port or a file
     descriptor.  'proc' should take a single argument which will be set
     by the event loop to 'out (see the documentation on
     event-loop-add-write-watch!  for further details).  It is intended
     to be called within a waitable procedure invoked by a-sync (which
     supplies the 'resume' argument).  The watch is multi-shot - it is
     for the user to bring it to an end at the right time by calling
     event-loop-remove-write-watch!  in the waitable procedure.  This
     procedure is mainly intended as something from which higher-level
     asynchronous file operations can be constructed.  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop

     The documentation on the event-loop-add-write-watch!  procedure
     explains why this procedure generally works best with an unbuffered
     or non-blocking port.

     Because this procedure takes a 'resume' argument derived from the
     a-sync procedure, it must (like the a-sync procedure) in practice
     be called in the same thread as that in which the event loop runs.

     This procedure should not throw an exception unless memory is
     exhausted.  If 'proc' throws, say because of port errors, and the
     exception is not caught locally, it will propagate out of
     event-loop-run!.

     As an example of how to use a-sync-write-watch!, here is the
     implementation of await-put-bytevector!:
          (define await-put-bytevector!
            (case-lambda
              [(await resume port bv) (await-put-bytevector! await resume #f port bv)]
              [(await resume loop port bv)
               (define length (bytevector-length bv))
               (define fd (port-file-descriptor port))
               (raise-exception-if-regular-file fd)

               (let ([index (c-write fd bv 0 length)])
                 (when (< index length)
          	 (a-sync-write-watch! resume
          			      port
          			      (lambda (status)
          				(set! index (+ index (c-write fd
          							      bv
          							      index
          							      (- length index))))
          				(if (< index length)
          				    'more
          				    #f))
          			      loop)
          	 (let next ((res (await)))
          	   (if (eq? res 'more)
          	       (next (await))
          	       (event-loop-remove-write-watch! port loop)))))]))

 -- Scheme Procedure: await-put-bytevector! await resume [loop] port bv
     This is a convenience procedure for use in an event loop, which
     will start a write watch on 'port' for writing the contents of a
     bytevector 'bv' to the port.  It calls 'await' while waiting for
     output to become available.  Provided 'port' is a non-blocking
     port, the event loop will not be blocked by this procedure even if
     only individual bytes can be written at any one time.  It is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments), and this
     procedure is implemented using a-sync-write-watch!.  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.

     'port' must be a non-blocking port, and may be a binary port or a
     textual port.  It should be unbuffered for output (say by applying
     the set-binary-port-output-size!  or set-textual-port-output-size!
     procedure to the port with a value of 0).  Having buffering on for
     input ports is generally desirable, but this leads to a
     complication with input-output ports for non-seekable devices (say
     for sockets) constructed with 'open-fd-input/output-port' with
     input buffering on, because if a read on the port were to be
     followed by a write (which includes a flush), an exception will
     occur when attempting a seek when moving from reading to writing.
     (Seeking when moving from reading to writing is necessary for
     buffered input-output ports for seekable files, but not for ports
     for files, such as sockets, which have no file position pointer and
     so are not seekable.)  In addition chez scheme does not in fact
     fully implement no buffering on textual ports, probably in order to
     support multi-byte encodings.

     To deal with this, this procedure by-passes the port's output
     buffer and sends the output to the underlying file descriptor
     directly.  Accordingly, if using a binary port constructed by
     'open-fd-input/output-port' which has had buffering on, or if using
     a textual port constructed by that procedure with or without
     buffering, and the port has previously been used for output by a
     procedure other than c-write or an await-put* procedure, the
     following approach should be adopted: (i) the port should be
     drained of input and any bytes drained dealt with appropriately,
     (ii) the 'clear-input-port' procedure should be applied to the port
     to reset input buffer pointers, and (iii) anything in the output
     buffer should then be flushed.  Thereafter the await-get*, c-write
     and await-put* procedures may be used for the port.  If using a
     binary port constructed by 'open-fd-output-port' with buffering on
     or a textual port constructed by that procedure with or without
     buffering, and the port has previously been used for output by a
     procedure other than c-write or an await-put* procedure, then it
     should be flushed before this procedure is called.

     This procedure will raise a &i/o-write-error exception if passed a
     regular file with a file position pointer (prior to version 0.11 a
     &serious exception was raised): there should be no need to use this
     procedure with regular files, because they cannot normally block on
     write and are always signalled as ready.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made), say
     because a regular file is passed to this procedure, memory is
     exhausted or a write exception is encountered.  With versions of
     this library before 0.11, any exceptions because of write errors
     after the first write would propagate out of event-loop-run!  and
     could not be caught locally.  Having write exceptions (say, because
     of EPIPE) interfering with anything using the event loop in this
     way was not a good approach, so from version 0.11 of this library
     all write exceptions will propagate in the first instance out of
     this procedure so that they may be caught locally, say by putting a
     'try' block around the call to this procedure.

     Here is how EPIPE might be tested for, using the 'try' form from
     the *note (a-sync try): try. library file (with linux and BSDs, the
     value of EPIPE is 32):
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (try (await-put-bytevector! await resume port bv)
          	       (except c
          		       [(and (irritants-condition? c)
          			     (= (cadr (condition-irritants c)) 32))
          			... do something to cater for EPIPE ...]))))
          (event-loop-run!)

     This procedure is first available in version 0.8 of this library.

     An example of the use of await-put-string!, which is implemented
     using this procedure, can be found in the example-client.ss and
     example-server.ss files in the docs directory.

 -- Scheme Procedure: await-put-string! await resume [loop] port text
     This is a convenience procedure for use in an event loop, which
     will start a write watch on 'port' for writing a string 'text' to
     the port.  It calls 'await' while waiting for output to become
     available.  Provided 'port' is a non-blocking port, the event loop
     will not be blocked by this procedure even if only individual
     characters or part characters can be written at any one time.  It
     is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     this procedure is implemented using await-put-bytevector!.  The
     'loop' argument is optional: this procedure operates on the event
     loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     'port' must be a non-blocking textual port.  It should be
     unbuffered for output (say by applying the
     set-textual-port-output-size!  procedure to the port with a value
     of 0), but if using a port constructed with 'open-fd-output-port'
     or 'open-fd-input/output-port', chez scheme does not in fact fully
     implement no buffering on textual ports, probably in order to
     support multi-byte encodings.  As explained in relation to
     await-put-bytevector!, this means that if a read were to be
     followed by a write (which includes a flush) on a textual port
     constructed by 'open-fd-input/output-port' for a non-seekable
     device, an exception will occur when attempting a seek when moving
     from reading to writing.  (Seeking when moving from reading to
     writing is necessary for buffered input-output ports for seekable
     files, but not for ports for files, such as sockets, which have no
     file position pointer and so are not seekable.)

     To deal with this, this procedure by-passes the port's output
     buffer and sends the output to the underlying file descriptor
     directly.  Accordingly, if using a port for a socket constructed by
     'open-fd-input/output-port' which has previously been used for
     output by a procedure other than c-write or an await-put*
     procedure, the following approach should be adopted: (i) the port
     should be drained of input and any characters drained dealt with
     appropriately, (ii) the 'clear-input-port' procedure should be
     applied to the port to reset input buffer pointers, and (iii)
     anything in the output buffer should then be flushed.  Thereafter
     the await-get*, c-write and await-put* procedures may be used for
     the port.  If using a port constructed by 'open-fd-output-port'
     which has previously been used for output by a procedure other than
     c-write or an await-put* procedure, then it should be flushed
     before this procedure is called.

     This procedure will raise a &i/o-write-error exception if passed a
     regular file with a file position pointer (prior to version 0.11 a
     &serious exception was raised): there should be no need to use this
     procedure with regular files, because they cannot normally block on
     write and are always signalled as ready.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made), say
     because a regular file is passed to this procedure, memory is
     exhausted, a conversion error arises or a write exception is
     encountered.  With versions of this library before 0.11, any
     exceptions because of write errors after the first write would
     propagate out of event-loop-run!  and could not be caught locally.
     Having write exceptions (say, because of EPIPE) interfering with
     anything using the event loop in this way was not a good approach,
     so from version 0.11 of this library all write exceptions will
     propagate in the first instance out of this procedure so that they
     may be caught locally, say by putting a 'try' block around the call
     to this procedure.

     Here is how EPIPE might be tested for, using the 'try' form from
     the *note (a-sync try): try. library file (with linux and BSDs, the
     value of EPIPE is 32):
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (try (await-put-string! await resume port "test")
          	       (except c
          		       [(and (irritants-condition? c)
          			     (= (cadr (condition-irritants c)) 32))
          			... do something to cater for EPIPE ...]))))
          (event-loop-run!)

     This procedure is first available in version 0.7 of this library.

     An example of the use of this procedure can be found in the
     example-client.ss and example-server.ss files in the docs
     directory.

 -- Scheme Procedure: c-write fd bv begin count
     This procedure is used by await-put-bytevector!  (and so by
     await-put-string!)  and is exported by event-loop.ss so that it can
     be used by other asynchronous procedures.  It makes a block write
     directly to output, bypassing any output buffers, using unix write.
     Although it can be used with blocking file descriptors, it is
     mainly intended for use with asynchronous procedures which must not
     block and must write immediately without requiring a subsequent
     flush to do so (chez scheme's textual ports always implement some
     buffering and will not write without a flush, irrespective of their
     buffering status on construction).

     This procedure provides a 'begin' parameter indicating the start of
     the sequence of bytes to be written, as an index.  'fd' is the file
     descriptor of the device to be written to, and it should normally
     be non-blocking (say, 'fd' is derived from a port to which
     set-port-nonblocking!  has been applied with an argument of #t).
     'bv' is a bytevector containing the bytes to be written.  'count'
     is the maximum number of bytes to be written.  This procedure
     returns the number of bytes actually written, which can be less
     than 'count' bytes.  The sum of 'begin' and 'count' must not be
     more than the length of the bytevector.  The use of a separate
     'begin' index enables the same bytevector to be written from
     repeatedly until all of it has been sent.

     Provided 'fd' is non-blocking, this procedure returns straight away
     (so 0 may be returned if the file descriptor is not available for
     writing because of insufficient space).  On a write error other
     than EAGAIN, EWOULDBLOCK or EINTR, a &i/o-write-error exception is
     raised which will give the errno number as an irritant (prior to
     version 0.11 a &serious exception was raised).  EINTR is handled
     internally and is not an error.

     This procedure is first available in version 0.8 of this library.

 -- Scheme Procedure: make-pipe [read-buffer-mode [write-buffer-mode
          [transcoder]]]
     This procedure makes a unix pipe using the system pipe() call.  It
     is needed internally by the event-loop implementation, and is
     exported as part of the event-loop library in case it is useful to
     users.

     This procedure returns two values, first a port for the read end of
     the pipe, and second a port for its write end.  If creating the
     pipe gives rise to an error, a scheme exception of type &serious
     will be raised.  The buffer mode arguments are optional (if not
     specified the read port will be block buffered and the write port
     will be unbuffered).  The transcoder argument is also optional: if
     provided the ports will be textual ports, otherwise they will be
     binary ports.  The ports are initially in blocking mode - use
     set-blocking-mode!  to change this if wanted.

     Setting a buffer mode of 'none' is ineffective for textual ports.

   Additional *await-connect-to-ipv4-host!*,
*await-connect-to-ipv6-host!*, *await-accept-ipv4-connection!*  and
*await-accept-ipv6-connection!*  procedures are provided by the
chez-simple-sockets package at
<https://github.com/ChrisVine/chez-simple-sockets>.  Examples of their
use are in the example-client.ss and example-server.ss files in the docs
directory.


File: chez-a-sync.info,  Node: compose,  Next: meeting,  Prev: event loop,  Up: Top

This (a-sync compose) library file provides a compose-a-sync macro
interface for the a-sync procedure provided by the *note (a-sync
coroutines): coroutines. library file.

 -- Syntax: (compose-a-sync [loop] ((var await-exp0) ...) await-exp1
          await-exp2 ...)
     This library file provides the compose-a-sync macro.  This does two
     things: first, it calls a-sync for you and deals with the resulting
     'await' and 'resume' procedures without exposing them, which for
     many simple uses makes a-sync easier to use; and secondly it
     enables asynchronous tasks to be more easily composed on an event
     loop with intermediate results, by using a let* type syntax (in
     fact, let* is used internally).

     The 'loop' argument of compose-a-sync is optional.  If an event
     loop constructed by make-event-loop is passed to 'loop', then that
     is the main loop on which the tasks will be composed, otherwise if
     there is no 'loop' argument given, the default main loop will be
     used.  This is followed by bindings which are optional (there need
     not be any), each of which must be initialised by an expression
     comprising the application of a 'compose-a-sync'-capable procedure,
     and following the bindings there must be a body of
     'compose-a-sync'-capable procedures executed solely for the purpose
     of asynchronous side effects (this macro does not, and cannot,
     return a value because as soon as the first await is made control
     is passed to the event loop).  As in the case of let*, unlike the
     bindings the body cannot be empty - there must be at least one
     expression comprising the application of a 'compose-a-sync'-capable
     procedure in the body.

     As in the case of let*, each 'compose-a-sync'-capable procedure
     initializing a binding can see the values of the initializations
     made prior to it.  Unlike let*, compose-a-sync blocks cannot be
     nested within other compose-a-sync blocks.  Furthermore, within a
     compose-a-sync block, the result obtained from a
     'compose-a-sync'-capable procedure cannot be passed directly as an
     argument to another 'compose-a-sync'-capable procedure: the
     intermediate result must be stored as the value of a binding in the
     compose-a-sync block.

     A 'compose-a-sync'-capable procedure is one which takes an 'await'
     and 'yield' procedure from a-sync as its first and second
     arguments, and (if the optional 'loop' argument of this macro is
     used) takes the event loop as its third argument, followed by such
     further arguments as it requires.  All of the await-task!,
     await-task-in-thread!, await-task-in-event-loop!, await-yield!,
     await-generator!, await-generator-in-thread!,
     await-generator-in-event-loop!, await-timeout!, await-sleep!,
     await-getline!, await-geteveryline!, await-getsomelines!,
     await-getblock!, await-geteveryblock!, await-getsomeblocks!,
     await-put-bytevector!  and await-put-string!  procedures provided
     by the *note (a-sync event-loop): event loop. library file are
     'compose-a-sync'-capable.  In addition, to make an ordinary body of
     code which does not block (and which does not need to invoke
     a-sync's await procedure) usable by compose-a-sync, the no-await
     macro can be used to generate a 'compose-a-sync'-capable procedure
     for it (see below).

     Each binding is initialized as if sequentially (although it is done
     asynchronously on the relevant event loop).  An initialization does
     not begin until an earlier one has completed.  In addition, each
     clause in the body is executed sequentially in turn, but does so
     asynchronously on the event loop using 'await' semantics.

     When calling a 'compose-a-sync'-capable procedure within a
     'compose-a-sync' block (including when initializing its bindings),
     the 'await' and 'yield' and event-loop arguments are not explicitly
     passed to it.  The compose-a-sync macro will do it for you.

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ([line (await-getline! (open-input-file "/dev/tty"))])
          	      ((no-await (format #t
          				 "The line was: ~A\n"
          				 line))))
          (event-loop-run!)

     The meeting-send and meeting-receive procedures in the (a-sync
     meeting) library file also meet the 'compose-a-sync'-capable
     requirements.  Here is an example using them:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (compose-a-sync ((datum (meeting-receive m1)))
          		((no-await (display datum)(newline))))
          (compose-a-sync ()
          		(meeting-send m1 100))
          (event-loop-run!)

     Each block of code within a compose-a-sync block will run
     independently of (and concurrently with) code in other
     compose-a-sync blocks.  Asynchronous operations are only serialized
     within any one compose-a-sync block.  As soon as any code calls
     a-sync's 'await' procedure in a compose-a-sync block,
     compose-a-sync will return and begin executing whatever follows it,
     and further execution of the compose-a-sync block will occur within
     the event loop concerned.

     Other examples of the use of this macro are given in the
     documentation of the *note (a-sync coroutines): coroutines. library
     file.

     This macro must (like the a-sync procedure) be called in the same
     thread as that in which the event loop runs.

 -- Syntax: (no-await body0 body1 ...)
     This macro will generate a 'compose-a-sync'-capable procedure from
     a body of code which does not block.  It can be passed to
     compose-a-sync, either for use as an initializer or as a clause in
     its body.  When used as an initializer, it evaluates to the value
     of the last expression in the 'no-await' body.

     If the body throws an exception which is not caught locally, it
     will propagate out of event-loop-run!.

     Here is an example of the use of no-await:

          (var ((no-await (+ a b))))


File: chez-a-sync.info,  Node: meeting,  Next: try,  Prev: compose,  Up: Top

As explained in the *note general overview: overview, each 'a-sync'
block (see *note (a-sync coroutines): coroutines.) or 'compose-a-sync'
block (see *note (a-sync compose): compose.) is a separate unit of
computation which appears within itself to proceed sequentially but
which also appears to execute concurrently with other 'a-sync' or
'compose-a-sync' blocks running on the same event loop.  Each 'a-sync'
or 'compose-a-sync' block is therefore in some sense analogous to a
thread of execution.

   This (a-sync meeting) library file provides a 'meeting' type which
can be used to synchronize between such "pseudo-threads" (that is,
between a-sync or compose-a-sync blocks).  A 'meeting' object is, in
terms of communicating sequential processes, an unbuffered (synchronous)
channel.  Unbuffered channels in the CSP style are a natural fit for use
with coroutines running on a single native thread (but not necessarily
for native threads running in parallel unless combined with work
stealing).  They are therefore a natural fit for synchronizing the
"pseudo-threads" provided by this library.

   Some of the things that can be done by using meetings can also be
done using await-generator!.  Note also that any one meeting object is
strictly for use by "pseudo-threads" which are running on the same event
loop, and so 'ipso facto' running in the same native OS thread.  To have
other native OS threads communicate with an event-loop, use
await-task-in-thread!, await-task-in-event-loop!,
await-generator-in-thread!  or await-generator-in-event-loop!  (see
*note (a-sync event-loop): event loop.).  Having said that, some things,
such as having one "pseudo-thread" join on another "pseudo-thread", are
more easily done with meeting objects.

   A "pseudo-thread" enters a meeting by applying meeting-receive (where
it is to receive a datum at the meeting) or meeting-send (where it is to
provide the datum) to a meeting object.  Once a "pseudo-thread" enters a
meeting it cannot leave until another co-operating "pseudo-thread" also
enters the meeting so the datum exchange can take place, or until the
meeting-close procedure is applied.  Once a datum exchange has taken
place, a meeting object can be reused for making another exchange
(provided the meeting object has not been closed).

   Synchronization occurs at the moment that the exchange of the datum
takes place.  Once one of the "pseudo-threads" leaves the meeting upon
meeting-receive or meeting-send (or both) returning, all subsequent
events are unsynchronized until another datum exchange is arranged.
This means that where two "pseudo-threads" share access to objects other
than the datum exchanged and they might be mutated, one "pseudo-thread"
is guaranteed to see a value of the unexchanged shared objects which is
not earlier than the value they held at the moment of datum exchange,
but it may or may not see a later value.

   Here is an example of the use of a meeting object:

     (set-default-event-loop!) ;; if none has yet been set
     (define m1 (make-meeting))

     (a-sync (lambda (await resume)
     	  (let loop ([datum (meeting-receive await resume m1)])
     	    (when (not (eq? datum 'stop-iteration))
     	      (display datum)
     	      (newline)
     	      (loop (meeting-receive await resume m1))))))

     (a-sync (lambda (await resume)
     	  (let loop ([count 0])
     	    (if (< count 4)
     		(begin
     		  (meeting-send await resume m1 count)
     		  (loop (+ count 1)))
     		(meeting-close m1)))))
     (event-loop-run!)

   See the documentation on the meeting-send and meeting-receive
procedures below for an example of multiple "pseudo-threads" sending to
or receiving from a single meeting object for fan in and fan out, and
for an example of those procedures 'selecting' on more than one meeting
object.

   The (a-sync meeting) library file provides the following procedures:

 -- Scheme Procedure: make-meeting [loop]
     This procedure makes and returns a meeting object.  Meetings are
     objects on which a-sync or compose-a-sync blocks running on the
     same event loop can synchronize by one passing a datum to another.
     The 'loop' argument specifies the event loop (as constructed by
     make-event-loop in the (a-sync event-loop) library file) with
     respect to which the meeting will be held: it is an error if the
     meeting-send or meeting-receive procedures are passed a different
     event loop as an argument.  The 'loop' argument is optional - if
     none is passed, or #f is passed, then the default event loop will
     be chosen.

     Strictly speaking this procedure can be called in any native OS
     thread, but since it carries out no synchronization of native
     threads the user would have to provide her own synchronization if
     called in other than the thread of the event loop with respect to
     which the meeting will be held; so it is best if this procedure is
     called in the thread of that event loop.

     This procedure is first available in version 0.13 of this library.

 -- Scheme Procedure: meeting? obj
     This procedure indicates whether 'obj' is a meeting object
     constructed by make-meeting.

     This procedure is first available in version 0.13 of this library.

 -- Scheme Procedure: meeting-close meeting
     This closes a meeting object.  It's purpose is to wake up any
     "pseudo-thread" (that is, any a-sync or compose-a-sync block)
     waiting in meeting-send or meeting-receive by causing either
     procedure to return with a 'stop-iteration value.

     Where that is not necessary (say, the receiver already knows how
     many items are to be sent), then this procedure does not need to be
     applied.  It is not needed in order to release resources.

     This procedure is first available in version 0.13 of this library.

 -- Scheme Procedure: meeting-ready? meeting
     This indicates whether applying message-send or message-receive (as
     the case may be) to the meeting object 'meeting' will return
     immediately: in other words, this procedure will return #t if
     another a-sync or compose-a-sync block is already waiting on the
     object or the meeting object has been closed, otherwise #f.

     This procedure is first available in version 0.13 of this library.

 -- Scheme Procedure: meeting-send await resume [loop] m0 [m1 ...] datum
     This sends a datum to a receiver which is running on the same event
     loop as the sender, via one or more meeting objects 'm0 m1 ...'.
     If no receiver is waiting for the datum, this procedure waits until
     a receiver calls meeting-receive on one of the meeting objects to
     request the datum.  If a receiver is already waiting, this
     procedure passes on the datum and returns immediately.

     The 'loop' argument is optional.  If not supplied, or #f is passed,
     this procedure will use the default event loop.  It is an error if
     this procedure is given a different event loop than the one which
     was passed to make-meeting on constructing the 'meeting' objects.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     With version 0.13 of this library, a sender could not invoke this
     procedure when another a-sync or compose-a-sync block running on
     the event loop concerned was already waiting to send on the same
     'meeting' object.  From version 0.14, multiple senders may wait on
     a meeting object to permit fan in.  The provided datum of each
     sender will be passed to a receiver (as and when a receiver becomes
     available) in the order in which this procedure was invoked.

     Here is an example of such a fan in:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "Hello from a-sync1")))
          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "Hello from a-sync2")))

          (a-sync (lambda (await resume)
          	  (let next ([count 0])
          	    (when (< count 2)
          	      (display (meeting-receive await resume m1))
          	      (newline)
          	      (next (+ count 1))))))
          (event-loop-run!)

     In addition, with version 0.13 of this library, only a single
     meeting object could be passed to this procedure.  From version
     0.14 this procedure has 'select'-like behavior: multiple meeting
     objects may be passed and this procedure will send to the first one
     which becomes available to receive the datum.

     Here is an example of selecting on send (here, meeting-send will
     send to the first meeting which becomes available for receiving,
     which is m2):

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (define m2 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 m2 "Hello")))

          (a-sync (lambda (await resume)
          	  (format #t "meeting-send says: ~a~%"
          		     (meeting-receive await resume m2))))
          (event-loop-run!)

     Once a datum exchange has taken place, the meeting object(s) can be
     reused for making another exchange (provided the meeting objects
     have not been closed).

     This procedure must be called in the native OS thread in which the
     event loop concerned runs.  To have other native OS threads
     communicate with an event-loop, use await-task-in-thread!,
     await-task-in-event-loop!, await-generator-in-thread!  or
     await-generator-in-event-loop!.

     This procedure always returns #f unless meeting-close has been
     applied to a meeting object, in which case 'stop-iteration is
     returned.  Note that if multiple meeting objects are passed to this
     procedure and one of them is then closed, this procedure will
     return 'stop-iteration and any wait will be abandonned.  It is
     usually a bad idea to close a meeting object on which this
     procedure is waiting where this procedure is selecting on more than
     one meeting object.

     This procedure is first available in version 0.13 of this library.

 -- Scheme Procedure: meeting-receive await resume [loop] m0 [m1 ...]
     This receives a datum from a sender running on the same event loop
     as the receiver, via one or more meeting objects 'm0 m1 ...'.  If
     no sender is waiting to pass the datum, this procedure waits until
     a sender calls meeting-send on one of the meeting objects to
     provide the datum.  If a sender is already waiting, this procedure
     returns immediately with the datum supplied.

     The 'loop' argument is optional.  If not supplied, or #f is passed,
     this procedure will use the default event loop.  It is an error if
     this procedure is given a different event loop than the one which
     was passed to make-meeting on constructing the 'meeting' objects.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     With version 0.13 of this library, a receiver could not invoke this
     procedure when another a-sync or compose-a-sync block running on
     the event loop concerned was already waiting to receive from the
     same 'meeting' object.  From version 0.14, multiple receivers may
     wait on a meeting object to permit fan out.  The waiting receivers
     will be released (as and when a sender provides a datum) in the
     order in which this procedure was invoked.

     Here is an example of such a fan out:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))

          (a-sync (lambda (await resume)
          	  (display (meeting-receive await resume m1))
          	  (newline)))
          (a-sync (lambda (await resume)
          	  (display (meeting-receive await resume m1))
          	  (newline)))

          (a-sync (lambda (await resume)
          	  (let next ([count 0])
          	    (when (< count 2)
          	      (meeting-send await resume m1 count)
          	      (next (+ count 1))))))
          (event-loop-run!)

     In addition, with version 0.13 of this library, only a single
     meeting object could be passed to this procedure.  From version
     0.14 this procedure has 'select'-like behavior: multiple meeting
     objects may be passed and this procedure will receive from the
     first one which sends a datum.

     Here is an example of selecting on receive:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (define m2 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "m1")))
          (a-sync (lambda (await resume)
          	  (meeting-send await resume m2 "m2")))

          (a-sync (lambda (await resume)
          	  (let next ([count 0])
          	    (when (< count 2)
          	      (format #t "Message received from ~a~%"
          			 (meeting-receive await resume m1 m2))
          	      (next (+ count 1))))))
          (event-loop-run!)

     Once a datum exchange has taken place, the meeting object(s) can be
     reused for making another exchange (provided the meeting objects
     have not been closed).

     This procedure must be called in the native OS thread in which the
     event loop concerned runs.  To have other native OS threads
     communicate with an event-loop, use await-task-in-thread!,
     await-task-in-event-loop!, await-generator-in-thread!  or
     await-generator-in-event-loop!.

     This procedure always returns the datum value supplied by
     meeting-send unless meeting-close has been applied to a meeting
     object, in which case 'stop-iteration is returned.  Note that if
     multiple meeting objects are passed to this procedure and one of
     them is then closed, this procedure will return 'stop-iteration and
     any wait will be abandonned.  It is usually a bad idea to close a
     meeting object on which this procedure is waiting where this
     procedure is selecting on more than one meeting object.

     This procedure is first available in version 0.13 of this library.


File: chez-a-sync.info,  Node: try,  Prev: meeting,  Up: Top

This (a-sync try) library file provides a 'try' macro for dealing with
exceptions.

 -- Syntax: (try body0 body1 ... (except condition cond-clause0
          cond-clause1 ...))
     Try is a macro used in the implementation of the event loop
     provided by this library, and is exported in case it is useful to
     users.  The macro has two keywords, 'try' and 'except'.  It
     executes the body clauses, and if an exception is raised by them
     passes control to the 'except' block with 'condition' set to the
     condition which was raised.  The cond-clauses are then evaluated as
     if in a cond expression.  If one of the cond tests is found to be
     true, or there is none found to be true but there is an else
     clause, then the relevant cond clause or else clause will be
     evaluated and returned.  If none of the cond tests in the
     cond-clauses is found to be true and there is no else clause, the
     exception condition will be re-raised as if by raise, for a
     dynamically enclosing try form, guard form or
     with-exception-handler form (if any) to handle.

     The return value of try, if there is no exception raised by the
     body clauses or any exception raised is handled by a cond-clause,
     is the value of the last expression of the body clauses or of the
     cond-clause, as the case may be.

     This is similar to but not the same as the R6RS 'guard' form.  The
     guard form has the property that if no cond test is found to be
     true in the cond clauses and there is no else clause, the exception
     condition will be re-raised with raise-continuable.  This is to
     allow continuable exceptions to propagate successfully through a
     'guard' form (albeit triggering any dynamic winds in doing so).  A
     further consequence is that when the condition is re-raised, that
     is done in the dynamic environment of the original call to raise or
     raise-continuable.  As mentioned, the 'try' form always re-raises
     with 'raise' (so in effect converting any continuable exception to
     a non-continuable one), and it does so in the dynamic environment
     in which the cond-clauses are evaluated, which is the dynamic
     environment of the original call to 'try'.

     Or put another way, the 'try' macro behaves like a conventional
     stack unwinding exception implementation.  'guard' does not
     necessarily do so.

     Continuable exceptions with generalised handling forms such as
     'guard' are generally to be avoided, as they may break any
     intermediate resource management which uses rethrows or dynamic
     winds.  Continuable exceptions are also usually unsuitable for use
     with asynchronous event handlers, which is why the 'try' form is
     used in the implementation of the event loop provided by this
     library.  But for cases where that is not true and you know what
     you are doing, you can use 'guard' instead of 'try' for maintaining
     continuable exceptions as continuable.

     The 'try' macro is first available in version 0.3 of this library.

     Here is an example of the use of try:
          (display (try (display "In outer try form\n")
          	      (try (display "In inner try form\n")
          		   (raise 'five)
          		   (except c
          			   [(eq? c 'six) 6]))
          	      (except c
          		      [(eq? c 'five) 5])))



Tag Table:
Node: Top83
Node: overview1130
Node: coroutines4452
Node: event loop22827
Node: compose108493
Node: meeting114715
Node: try129185

End Tag Table
